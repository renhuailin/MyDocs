Redis Notes
---------

# List 操作

```
#获取列表长度
127.0.0.1:6379> LLEN "huobi-candlesticks"
#获取列表的内容
127.0.0.1:6379> LRANGE mylist -100 100
```

# Auth 操作

```
 127.0.0.1:6379> CONFIG SET requirepass renhl.com
 127.0.0.1:6379> ping
 (error) NOAUTH Authentication required.

 127.0.0.1:6379> auth renhl.com
 127.0.0.1:6379> ping
 PONG
```

用 Sentinel来实现主从的自动切换。

# 关于数据库

redis的数据库是0序的，没有name。0是默认数据库。在集群环境下不能使用0以外的数据库。


# 持久化


好的，我们来详细、清晰地剖析 Redis 的两大持久化策略：**RDB (Redis Database)** 和 **AOF (Append-Only File)**。理解它们的区别、优缺点和适用场景，对于正确地配置和使用 Redis 至关重要。

---

### RDB (Redis Database) - 快照持久化

#### 1. 是什么？
RDB 是一种**时间点快照 (Point-in-time Snapshot)** 的持久化方式。在满足特定条件时（比如时间间隔、写入操作次数），Redis 会 fork 一个子进程，将**某一时刻内存中的所有数据**完整地写入到一个经过压缩的二进制文件（默认为 `dump.rdb`）中。

你可以把它想象成给你的 Redis 数据库**拍了一张照片**。

#### 2. 工作方式
*   **触发机制**:
    *   **自动触发**: 在 `redis.conf` 文件中通过 `save` 配置来触发。例如 `save 900 1` 表示如果在 900 秒内，至少有 1 个 key 发生了变化，就自动执行一次 RDB 快照。
    *   **手动触发**: 客户端执行 `SAVE` 或 `BGSAVE` 命令。
        *   `SAVE`: 阻塞 Redis 主进程，直到 RDB 文件创建完毕。在生产环境中**几乎不使用**。
        *   `BGSAVE`: Redis fork 一个子进程在后台进行快照，主进程继续处理客户端请求，**这是推荐的方式**。
    *   **关机时**: 执行 `shutdown` 命令时，如果没有开启 AOF，Redis 会自动执行一次 `SAVE`。

#### 3. 优点
*   **文件紧凑、恢复速度快**: `dump.rdb` 是一个经过压缩的二进制文件，体积比 AOF 文件小得多。在恢复数据时，Redis 只需要直接读取并解析这个文件，将其加载到内存中即可，速度非常快。
*   **对性能影响小 (BGSAVE)**: 使用 `BGSAVE` 时，实际的 I/O 操作由子进程完成，主进程不受影响，可以继续提供服务。这使得 RDB 非常适合做**冷备份 (Cold Backup)**，比如每天定时备份一次数据。
*   **简单**: 只有一个文件，易于管理、传输和备份。

#### 4. 缺点
*   **数据丢失风险高**: RDB 是间隔性地进行快照。如果在上一次快照和下一次快照之间，Redis 发生了宕机，那么这个时间段内所有的数据都会**完全丢失**。例如，如果你配置为每 5 分钟保存一次，那么在最坏的情况下，你可能会丢失接近 5 分钟的数据。
*   **Fork 子进程的开销**: 当数据集非常大时，`fork()` 子进程可能会消耗较多的时间和内存，甚至可能导致 Redis 服务在短时间内停顿（特别是在内存使用紧张的虚拟机上）。

#### 5. 应用场景
*   **数据备份与灾难恢复**: RDB 文件非常适合用于定期备份（如每天、每周），并传输到远程服务器或云存储上，用于灾难恢复。
*   **对数据完整性要求不高的场景**: 如果你可以容忍丢失几分钟的数据（例如，缓存、分析数据），RDB 是一个简单高效的选择。
*   **主从复制**: 在主从复制的初始同步阶段，主节点会生成一个 RDB 文件发送给从节点，从节点加载这个 RDB 文件来快速同步数据。

---

### AOF (Append-Only File) - 日志追加持久化

#### 1. 是什么？
AOF 是一种**日志追加**的持久化方式。它会将 Redis 服务器执行的**每一条写命令**（如 `SET`, `INCR`, `LPUSH`）都以 Redis 的协议格式记录到一个日志文件（默认为 `appendonly.aof`）的末尾。

你可以把它想象成一个**操作日志记录本**，记录了让数据库达到当前状态的所有步骤。

#### 2. 工作方式
*   **写命令记录**: 当写命令到达时，Redis 会先将其追加到 AOF 缓冲区 (`aof_buf`)。
*   **同步到磁盘 (`fsync`)**: Redis 会根据 `appendfsync` 配置策略，将缓冲区的内容写入到 AOF 文件中。
    *   `always`: 每执行一条写命令就立即同步到磁盘。**最安全，但性能最差**。
    *   `everysec`: **默认选项**。每秒同步一次。在性能和数据安全之间取得了很好的平衡。最多只会丢失 1 秒的数据。
    *   `no`: 完全由操作系统来决定何时同步。速度最快，但数据丢失风险最高。
*   **AOF 重写 (Rewrite)**: 随着时间推移，AOF 文件会越来越大。AOF 重写机制可以在不中断服务的情况下，创建一个新的、更紧凑的 AOF 文件。它会读取当前内存中的数据，然后用最少的命令来表示这些数据（例如，对一个计数器执行了 100 次 `INCR`，重写后就只有一个 `SET count 100` 命令）。

#### 3. 优点
*   **数据持久性更好**: 根据 `appendfsync` 的配置，你可以实现几乎不丢失数据（`always`）或最多只丢失 1 秒数据（`everysec`）。数据安全性远高于 RDB。
*   **文件可靠**: 即使 AOF 文件在写入时被意外中断（如磁盘满了），Redis 也提供了 `redis-check-aof` 工具来修复它，使其可以被正常加载。

#### 4. 缺点
*   **文件体积大**: AOF 文件通常比相同数据集的 RDB 文件大得多，因为它记录的是操作过程而不是最终结果。
*   **恢复速度慢**: 在重启时，Redis 需要逐条重新执行 AOF 文件中的所有命令来恢复数据状态，当文件很大时，这个过程会比加载 RDB 慢很多。
*   **有一定性能开销**: 即使是 `everysec` 策略，每秒一次的 `fsync` 操作也会对 Redis 的 QPS 产生一定的影响，尽管通常可以接受。

#### 5. 应用场景
*   **对数据完整性要求高的场景**: 如果你的应用不能容忍丢失超过几秒的数据（例如，交易系统、订单队列），AOF 是必须的选择。
*   **生产环境的主力持久化方案**: 在大多数生产环境中，通常会**同时开启 RDB 和 AOF**，以兼顾数据安全和备份恢复的效率。

---

### RDB vs. AOF 总结对比

| 特性 | RDB (快照) | AOF (日志追加) |
| :--- | :--- | :--- |
| **数据安全性** | **低** (可能丢失分钟级数据) | **高** (可配置为只丢失最多1秒数据) |
| **文件大小** | **小** (压缩二进制) | **大** (文本协议日志) |
| **恢复速度** | **快** (直接加载) | **慢** (逐条执行命令) |
| **对性能影响** | `BGSAVE` 时对主进程影响小，但 `fork` 可能有瞬间停顿 | 持续的 I/O 操作，对 QPS 有一定影响 |
| **核心机制** | 周期性地将内存数据写入文件 | 将每一条写命令追加到文件 |

### 生产环境的最佳实践

**推荐配置：同时开启 RDB 和 AOF**

这是 Redis 官方和社区普遍推荐的“黄金标准”配置。

*   **AOF 作为主要的持久化方式**，确保数据的最大安全性。当 Redis 重启时，它会**优先加载 AOF 文件**来恢复数据，因为它通常包含更完整的数据。
*   **RDB 作为补充的备份和恢复手段**。你可以配置 RDB 进行较为稀疏的快照（如每小时或每天一次），并将生成的 `.rdb` 文件用于：
    *   **冷备份**: 归档到其他存储介质。
    *   **灾难恢复**: 在 AOF 文件损坏或丢失等极端情况下，至少还能恢复到上一个 RDB 快照的时间点。
    *   **加速主从同步**。

通过这种混合持久化策略，你可以在数据安全、性能和运维便利性之间取得最佳的平衡。